
    const contractAddress = "0x5f53dDC137f0f4A4147aB8949b479bb41CCb15e5";
    let web3;
    let contract;
    let currentAddress;
    let isOwner = false;
    let contractDestroyed = false;

    // Contract ABI 
    const contractABI = [
	{
		"inputs": [],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "uint256",
				"name": "id",
				"type": "uint256"
			}
		],
		"name": "AuctionCancelled",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "uint256",
				"name": "id",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "address",
				"name": "seller",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "title",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "startPrice",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "endBlock",
				"type": "uint256"
			}
		],
		"name": "AuctionCreated",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "uint256",
				"name": "id",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "address",
				"name": "winner",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "address",
				"name": "seller",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amountToSeller",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "fee",
				"type": "uint256"
			}
		],
		"name": "AuctionEnded",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "uint256",
				"name": "auctionId",
				"type": "uint256"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "seller",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "sellerAmount",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "feeAmount",
				"type": "uint256"
			}
		],
		"name": "AuctionFulfilled",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "address",
				"name": "by",
				"type": "address"
			}
		],
		"name": "ContractDestroyed",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "uint256",
				"name": "id",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "address",
				"name": "bidder",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "totalBid",
				"type": "uint256"
			}
		],
		"name": "NewBid",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "previousOwner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "newOwner",
				"type": "address"
			}
		],
		"name": "OwnershipTransferred",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "address",
				"name": "by",
				"type": "address"
			}
		],
		"name": "Paused",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "bidder",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "RefundClaimed",
		"type": "event"
	},
	{
		"inputs": [],
		"name": "AUCTION_FEE",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "SUPER_ADMIN",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"name": "auctions",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "id",
				"type": "uint256"
			},
			{
				"internalType": "string",
				"name": "title",
				"type": "string"
			},
			{
				"internalType": "address payable",
				"name": "seller",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "startPrice",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "highestBid",
				"type": "uint256"
			},
			{
				"internalType": "address payable",
				"name": "highestBidder",
				"type": "address"
			},
			{
				"internalType": "enum AuctionContract.State",
				"name": "state",
				"type": "uint8"
			},
			{
				"internalType": "uint256",
				"name": "endBlock",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "user",
				"type": "address"
			}
		],
		"name": "ban",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"name": "banned",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			},
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"name": "bids",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "id",
				"type": "uint256"
			}
		],
		"name": "cancelAuction",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "claimRefund",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "title",
				"type": "string"
			},
			{
				"internalType": "uint256",
				"name": "startPrice",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "durationBlocks",
				"type": "uint256"
			}
		],
		"name": "createAuction",
		"outputs": [],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "destroyContract",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "id",
				"type": "uint256"
			}
		],
		"name": "endAuction",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "auctionId",
				"type": "uint256"
			}
		],
		"name": "fulfillAuction",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "getActiveAuctions",
		"outputs": [
			{
				"internalType": "uint256[]",
				"name": "ids",
				"type": "uint256[]"
			},
			{
				"internalType": "address[]",
				"name": "sellers",
				"type": "address[]"
			},
			{
				"internalType": "string[]",
				"name": "titles",
				"type": "string[]"
			},
			{
				"internalType": "uint256[]",
				"name": "currentPrices",
				"type": "uint256[]"
			},
			{
				"internalType": "uint256[]",
				"name": "endBlocks",
				"type": "uint256[]"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "getBalance",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "getCancelledAuctions",
		"outputs": [
			{
				"components": [
					{
						"internalType": "uint256",
						"name": "id",
						"type": "uint256"
					},
					{
						"internalType": "string",
						"name": "title",
						"type": "string"
					},
					{
						"internalType": "address payable",
						"name": "seller",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "startPrice",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "highestBid",
						"type": "uint256"
					},
					{
						"internalType": "address payable",
						"name": "highestBidder",
						"type": "address"
					},
					{
						"internalType": "enum AuctionContract.State",
						"name": "state",
						"type": "uint8"
					},
					{
						"internalType": "uint256",
						"name": "endBlock",
						"type": "uint256"
					}
				],
				"internalType": "struct AuctionContract.Auction[]",
				"name": "",
				"type": "tuple[]"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "getEndedAuctions",
		"outputs": [
			{
				"components": [
					{
						"internalType": "uint256",
						"name": "id",
						"type": "uint256"
					},
					{
						"internalType": "string",
						"name": "title",
						"type": "string"
					},
					{
						"internalType": "address payable",
						"name": "seller",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "startPrice",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "highestBid",
						"type": "uint256"
					},
					{
						"internalType": "address payable",
						"name": "highestBidder",
						"type": "address"
					},
					{
						"internalType": "enum AuctionContract.State",
						"name": "state",
						"type": "uint8"
					},
					{
						"internalType": "uint256",
						"name": "endBlock",
						"type": "uint256"
					}
				],
				"internalType": "struct AuctionContract.Auction[]",
				"name": "",
				"type": "tuple[]"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "id",
				"type": "uint256"
			}
		],
		"name": "getHighestBidder",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "id",
				"type": "uint256"
			}
		],
		"name": "newBid",
		"outputs": [],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "nextAuctionId",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "owner",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "pauseContract",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "paused",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "pendingPlatformFees",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"name": "pendingRefunds",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "totalCollected",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "newOwner",
				"type": "address"
			}
		],
		"name": "transferOwnership",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "user",
				"type": "address"
			}
		],
		"name": "unban",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "withdrawPlatformFees",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	}
];

    // -------------------
    // Initialization
    // -------------------
    document.addEventListener("DOMContentLoaded", async () => {
      if (!window.ethereum) {
        alert("Please install MetaMask to use this dApp");
        return;
      }

      try {
        web3 = new Web3(window.ethereum);
        await window.ethereum.request({ method: "eth_requestAccounts" });
        const accounts = await web3.eth.getAccounts();
        currentAddress = accounts[0];
        
        updateConnectionUI();
        
        contract = new web3.eth.Contract(contractABI, contractAddress);
        
        await checkOwnerStatus();
        await refreshAll();
        setupContractEvents();
             
      // Refresh Button
    const refreshBtn = document.getElementById("refreshBtn");
    if(refreshBtn) refreshBtn.addEventListener("click", refreshAll);

    // Create Auction Button
    const createAuctionBtn = document.getElementById("createAuctionBtn");
    if(createAuctionBtn) createAuctionBtn.addEventListener("click", createAuction);

    // Claim Refunds Button
    const claimBtn = document.getElementById("claimBtn");
    if(claimBtn) claimBtn.addEventListener("click", claimRefundsB);

    // Withdraw Fees Button
    const withdrawFeesBtn = document.getElementById("withdrawFeesBtn");
    if(withdrawFeesBtn) withdrawFeesBtn.addEventListener("click", withdrawFees);

    // Transfer Ownership Button
    const changeOwnerBtn = document.getElementById("changeOwnerBtn");
    if(changeOwnerBtn) changeOwnerBtn.addEventListener("click", changeOwner);

    // Ban Seller Button
    const cancelBtn = document.getElementById("cancelBtn");
    if(cancelBtn) cancelBtn.addEventListener("click", banSeller);

    // Destroy Contract Button
    const destroyContractBtn = document.getElementById("destroyContractBtn");
    if(destroyContractBtn) destroyContractBtn.addEventListener("click", destroyContract);
    
    } catch (error) {
        console.error("Initialization error:", error);
        alert("Error: " + error.message);
      }
  });

    

    async function checkOwnerStatus() {
      try {
        const owner = await contract.methods.owner().call();
        isOwner = owner.toLowerCase() === currentAddress.toLowerCase();
        
        const adminControls = document.getElementById("adminControls");
        const notOwnerMessage = document.getElementById("notOwnerMessage");
        const createBtn = document.querySelector(".btn-create");
        
        if (isOwner) {
          adminControls.style.display = "block";
          notOwnerMessage.style.display = "none";
          if (createBtn) {
            createBtn.disabled = true;
            createBtn.title = "Contract owner cannot create auctions";
            createBtn.style.opacity = "0.5";
          }
        } else {
          adminControls.style.display = "none";
          notOwnerMessage.style.display = "block";
          if (createBtn) {
            createBtn.disabled = false;
            createBtn.title = "";
            createBtn.style.opacity = "1";
          }
        }
      } catch (error) {
        console.error("Error checking owner:", error);
      }
    }

    function updateConnectionUI() {
      const addressElement = document.getElementById("currentAddress");
      const statusElement = document.getElementById("connectionStatus");
      
      if (addressElement) {
        addressElement.textContent = currentAddress ? 
          `${currentAddress.slice(0, 6)}...${currentAddress.slice(-4)}` : 
          "Not connected";
      }
      
      if (statusElement) {
        if (currentAddress) {
          statusElement.textContent = "● Connected";
          statusElement.className = "connection-status connected";
        } else {
          statusElement.textContent = "● Disconnected";
          statusElement.className = "connection-status disconnected";
        }
      }
    }

    function setupEventListeners() {
      window.ethereum.on('accountsChanged', async (accounts) => {
        currentAddress = accounts[0] || null;
        updateConnectionUI();
        await checkOwnerStatus();
        await refreshAll();
      });
      
      window.ethereum.on('chainChanged', () => {
        location.reload();
      });
    }

    function setupContractEvents() {
     contract.events.AuctionCreated({}, () => refreshAll());
     contract.events.NewBid({}, () => refreshAll());
     contract.events.AuctionCancelled({}, () => refreshAll());
     contract.events.AuctionEnded({}, () => refreshAll());
     contract.events.AuctionFulfilled({}, () => refreshAll());
   }


    // -------------------
    // Refresh All Data
    // -------------------
    async function refreshAll() {
      console.log("Refreshing all data...");
      try {
        await updateHeaderInfo();
        await loadAllAuctions();
        await loadFulfilledAuctions();
        await loadCancelledAuctions();
        await updateClaimUI();
        console.log("Refresh completed successfully");
      } catch (error) {
        console.error("Refresh error:", error);
      }
    }

    // -------------------
    // Section 1: Header Info (Real-time updates)
    // -------------------
    async function updateHeaderInfo() {
      try {
        // Contract owner
        const owner = await contract.methods.owner().call();
        document.getElementById('ownerAddress').textContent = 
          `${owner.slice(0, 6)}...${owner.slice(-4)}`;
        
        // Contract balance
        const balance = await web3.eth.getBalance(contractAddress);
        const balanceEth = web3.utils.fromWei(balance, 'ether');
        document.getElementById('contractBalance').textContent = 
          `${parseFloat(balanceEth).toFixed(3)} ETH`;
        
        // Collected fees (20% of fulfilled auctions)
        const fees = await contract.methods.totalCollected().call();
        const feesEth = web3.utils.fromWei(fees, 'ether');
        document.getElementById('collectedFees').textContent = 
          `${parseFloat(feesEth).toFixed(3)} ETH`;
        
      } catch (error) {
        console.error("Error updating header:", error);
      }
    }

    // -------------------
    // Section 2: Create Auction
    // -------------------
    async function createAuction() {
     const title = document.getElementById('auctionTitle').value.trim();
     const price = document.getElementById('startingPriceEth').value.trim();
     const duration = document.getElementById('auctionDuration').value.trim();
     const statusElement = document.getElementById('createStatus');

  if (!title || !price || !duration) {
    alert("Please fill all fields");
    return;
  }

  if (parseFloat(price) <= 0) {
    alert("Starting price must be greater than 0");
    return;
  }

  if (parseInt(duration) <= 0) {
    alert("Duration must be greater than 0 blocks");
    return;
  }

  const startPriceWei = web3.utils.toWei(price, 'ether');
  const feeWei = web3.utils.toWei('0.02', 'ether');

  statusElement.textContent = "Creating auction...";
  statusElement.className = "status-message info";

  try {
    await contract.methods.createAuction(title, startPriceWei, duration)
      .send({
        from: currentAddress,
        value: feeWei,
        gas: 300000
      })
      .on('transactionHash', (hash) => {
        console.log("Transaction hash:", hash);
        statusElement.textContent = `Transaction sent: ${hash.slice(0, 10)}...`;
      })
      .on('receipt', () => {
        statusElement.textContent = "✅ Auction created successfully!";
        statusElement.className = "status-message success";

        // Clear form
        document.getElementById('auctionTitle').value = '';
        document.getElementById('startingPriceEth').value = '';
        document.getElementById('auctionDuration').value = '';

        loadAllAuctions();

        setTimeout(() => {
          statusElement.textContent = '';
          statusElement.className = "status-message";
        }, 3000);
      })
      .on('error', (error) => {
        console.error("Transaction error:", error);
        statusElement.textContent =
          "❌ Error: " + (error.message || "Transaction failed");
        statusElement.className = "status-message error";
      });

  } catch (error) {
    console.error("Create auction error:", error);
    statusElement.textContent = "❌ Error: " + error.message;
    statusElement.className = "status-message error";
  }
 }

    

 // -------------------
// Section 3: Live Auctions 
// -------------------
async function loadAllAuctions() {
  const container = document.getElementById('auctionList');
  container.innerHTML = '<div class="no-items">Loading auctions...</div>';

  try {
    const currentBlock = await web3.eth.getBlockNumber();
    const nextId = await contract.methods.nextAuctionId().call();
    
    if (nextId <= 1) {
      container.innerHTML = '<div class="no-items">No auctions found</div>';
      return;
    }

    container.innerHTML = ''; // Καθαρίζουμε το loading message
    let hasAuctions = false;

    // Διαβάζουμε όλα τα auctions ένα-ένα
    for (let i = 1; i < nextId; i++) {
      try {
        const auction = await contract.methods.auctions(i).call();
        const auctionState = Number(auction.state);
        
        // Παραλείπουμε τα fulfilled και cancelled
        if (auctionState === 2 || auctionState === 3) continue;
        
        const id = Number(auction.id);
        const seller = auction.seller;
        const title = auction.title;
        const currentPriceWei = auction.highestBid > 0 ? auction.highestBid : auction.startPrice;
        const currentPriceEth = web3.utils.fromWei(currentPriceWei.toString(), 'ether');
        
        // User role
        let userRole = 'spectator';
        let roleText = 'Spectator';
        if (seller.toLowerCase() === currentAddress.toLowerCase()) {
          userRole = 'seller';
          roleText = 'Seller';
        } else if (
          auction.highestBidder &&
          auction.highestBidder.toLowerCase() === currentAddress.toLowerCase()
        ) {
          userRole = 'bidder';
          roleText = 'Highest Bidder';
        }

        // Determine auction status
        let isActive = false;
        let isEndedButNotFulfilled = false;
        let needsAutoEnd = false;
        
        if (auctionState === 0) { // State.Active
          if (currentBlock < auction.endBlock) {
            isActive = true;
          } else {
            // Time has expired - try to auto-end
            needsAutoEnd = true;
            isEndedButNotFulfilled = true;
          }
        } else if (auctionState === 1) { // State.Ended
          isEndedButNotFulfilled = true;
        }

        // ΑΥΤΟΜΑΤΟ END - Μόνο αν ο χρήστης είναι seller
        if (needsAutoEnd && userRole === 'seller') {
          try {
            console.log(`Auto-ending auction ${id}...`);
            await contract.methods.endAuction(id)
              .send({
                from: currentAddress,
                gas: 150000
              });
            
            // After auto-end, refresh the auction data
            const updatedAuction = await contract.methods.auctions(id).call();
            auction.state = updatedAuction.state;
            auctionState = Number(updatedAuction.state);
            
            // Update status after auto-end
            if (auctionState === 1) {
              isEndedButNotFulfilled = true;
              needsAutoEnd = false;
            }
            
            console.log(`Auction ${id} auto-ended successfully`);
          } catch (error) {
            console.warn(`Could not auto-end auction ${id}:`, error.message);
            // Προχωράμε με το original state
          }
        }

        // Time left / Status
        let timeLeft = '-';
        let statusText = '';
        
        if (isActive) {
          const blocksLeft = auction.endBlock - currentBlock;
          const minutes = Math.max(Math.floor((blocksLeft * 15) / 60), 1);
          timeLeft = `${blocksLeft} blocks (≈${minutes}min)`;
          statusText = 'Active';
        } else if (isEndedButNotFulfilled) {
          statusText = 'Ended';
          if (needsAutoEnd) {
            timeLeft = 'EXPIRED';
            statusText = 'Expired (needs seller)';
          } else {
            const blocksPassed = currentBlock - auction.endBlock;
            const hoursPassed = Math.floor((blocksPassed * 15) / 3600);
            if (hoursPassed > 0) {
              timeLeft = `Ended ${hoursPassed}h ago`;
            } else {
              timeLeft = 'Recently ended';
            }
          }
        }

        // Action buttons
        let actionHTML = '';
        
        if (isActive) {
          if (userRole === 'seller') {
            actionHTML = `<button class="btn-cancel" onclick="cancelAuction(${id})">Cancel</button>`;
          } else if (userRole === 'spectator') {
            const minBid = (parseFloat(currentPriceEth) + 0.001).toFixed(3);
            actionHTML = `
              <div class="bid-controls">
                <input type="number" class="bid-input" step="0.001" min="${minBid}" value="${minBid}">
                <button class="btn-bid" onclick="placeBid(${id})">Bid</button>
              </div>
            `;
          } else {
            actionHTML = '-';
          }
        } else if (isEndedButNotFulfilled) {
          // Already ended, ready for fulfill
          if (userRole === 'seller') {
            if (auction.highestBid > 0) {
              actionHTML = `<button class="btn-fulfill" onclick="fulfillAuction(${id})">Fulfill</button>`;
            } else {
              actionHTML = `<button class="btn-cancel" onclick="cancelAuction(${id})">Cancel</button>`;
            }
          } else if (userRole === 'bidder') {
            actionHTML = '<span style="color: #666;">Waiting for seller...</span>';
          } else {
            actionHTML = '-';
          }
        }

        // Προσθήκη του auction στη λίστα μόνο αν:
        // 1. Είναι active, ή
        // 2. Είναι ended και ο χρήστης είναι seller ή bidder
        const shouldShow = isActive || 
                          (isEndedButNotFulfilled && (userRole === 'seller' || userRole === 'bidder'));
        
        if (shouldShow) {
          hasAuctions = true;
          const item = document.createElement('div');
          item.className = 'auction-item ' + (isActive ? 'active' : 'ended');
          item.dataset.id = id;
          item.innerHTML = `
            <span>#${id}</span>
            <span class="address" title="${seller}">${seller.slice(0,6)}...${seller.slice(-4)}</span>
            <span title="${title}">${title.length > 20 ? title.substring(0, 20) + '...' : title}</span>
            <span class="price">${parseFloat(currentPriceEth).toFixed(3)} ETH</span>
            <span class="time-left">${timeLeft}</span>
            <span class="role ${userRole}">${roleText}</span>
            <span class="status ${isActive ? 'active' : 'ended'}">${statusText}</span>
            <span>${actionHTML}</span>
          `;
          container.appendChild(item);
        }
      } catch (error) {
        console.warn(`Error loading auction ${i}:`, error);
        continue;
      }
    }

    if (!hasAuctions) {
      container.innerHTML = '<div class="no-items">No auctions to display</div>';
    }
  } catch (error) {
    console.error('Error loading auctions:', error);
    container.innerHTML = '<div class="no-items error">Error loading auctions</div>';
  }
}

// -------------------
// End Auction Function 
// -------------------
async function endAuction(auctionId) {
  if (!confirm("End this auction? This will move it to 'Ended' state where you can fulfill it to receive payment.")) return;
  
  try {
    await contract.methods.endAuction(auctionId)
      .send({
        from: currentAddress,
        gas: 200000
      })
      .on('transactionHash', () => {
        // Δείξε loading state
        const item = document.querySelector(`.auction-item[data-id="${auctionId}"]`);
        if (item) {
          const actionSpan = item.querySelector('span:last-child');
          actionSpan.innerHTML = '<span style="color: #666;">Ending...</span>';
        }
      })
      .on('receipt', () => {
        alert("✅ Auction ended successfully! You can now fulfill it to receive payment.");
        loadAllAuctions(); // Refresh the list
      })
      .on('error', (error) => {
        alert("❌ Failed to end auction: " + error.message);
      });
  } catch (error) {
    console.error("End auction error:", error);
    alert("Error: " + error.message);
  }
}


    // -------------------
    // Place Bid
    // -------------------
    async function placeBid(auctionId) {
      try {
        const auctionItem = document.querySelector(`.auction-item[data-id="${auctionId}"]`);
        if (!auctionItem) return;
        
        const bidInput = auctionItem.querySelector('.bid-input');
        const bidAmount = bidInput.value.trim();
        
        if (!bidAmount || parseFloat(bidAmount) <= 0) {
          alert("Please enter a valid bid amount");
          return;
        }
        
        const auction = await contract.methods.auctions(auctionId).call();
        const currentPrice = auction.highestBid > 0 ? auction.highestBid : auction.startPrice;
        const currentPriceEth = web3.utils.fromWei(currentPrice, 'ether');
        const minBid = parseFloat(currentPriceEth) + 0.001;
        
        if (parseFloat(bidAmount) < minBid) {
          alert(`Minimum bid is ${minBid.toFixed(3)} ETH`);
          bidInput.value = minBid.toFixed(3);
          return;
        }
        
        const bidWei = web3.utils.toWei(bidAmount, 'ether');
        
        await contract.methods.newBid(auctionId)
          .send({
            from: currentAddress,
            value: bidWei,
            gas: 200000
          })
          .on('transactionHash', () => {
            bidInput.disabled = true;
            auctionItem.querySelector('.btn-bid').disabled = true;
            auctionItem.querySelector('.btn-bid').textContent = "Processing...";
          })
          .on('receipt', () => {
            alert("✅ Bid placed successfully!");
            refreshAll();
          })
          .on('error', (error) => {
            alert("❌ Bid failed: " + error.message);
          });
          
      } catch (error) {
        console.error("Place bid error:", error);
        alert("Error: " + error.message);
      }
    }

    // -------------------
    // Cancel Auction
    // -------------------
    async function cancelAuction(auctionId) {
      if (!confirm("Are you sure you want to cancel this auction?")) return;
      
      try {
        await contract.methods.cancelAuction(auctionId)
          .send({
            from: currentAddress,
            gas: 200000
          })
          .on('receipt', () => {
            alert("✅ Auction cancelled successfully!");
            refreshAll();
          })
          .on('error', (error) => {
            alert("❌ Cancellation failed: " + error.message);
          });
          
      } catch (error) {
        console.error("Cancel auction error:", error);
        alert("Error: " + error.message);
      }
    }

    // -------------------
    // Fulfill Auction
    // -------------------
    async function fulfillAuction(auctionId) {
      const auction = await contract.methods.auctions(auctionId).call();
      const finalPrice = web3.utils.fromWei(auction.highestBid, 'ether');
      const sellerAmount = (parseFloat(finalPrice) * 0.8).toFixed(3);
      const feeAmount = (parseFloat(finalPrice) * 0.2).toFixed(3);
      
      const confirmMsg = `Fulfill Auction #${auctionId}\n\n` +
                        `Item: ${auction.title}\n` +
                        `Final Price: ${finalPrice} ETH\n\n` +
                        `Seller receives: ${sellerAmount} ETH (80%)\n` +
                        `Platform fee: ${feeAmount} ETH (20%)\n\n` +
                        `Proceed with fulfillment?`;
      
      if (!confirm(confirmMsg)) return;
      
      try {
        await contract.methods.fulfillAuction(auctionId)
          .send({
            from: currentAddress,
            gas: 250000
          })
          .on('receipt', () => {
            alert("✅ Auction fulfilled successfully!");
            refreshAll();
          })
          .on('error', (error) => {
            alert("❌ Fulfillment failed: " + error.message);
          });
          
      } catch (error) {
        console.error("Fulfill auction error:", error);
        alert("Error: " + error.message);
      }
    }

    // -------------------
    // Section 4: Fulfilled Auctions
    // -------------------
    async function loadFulfilledAuctions() {
      try {
        const container = document.getElementById('fulfilledAuctionList');
        
        // We need to check each auction since there's no getFulfilledAuctions function
        const nextId = await contract.methods.nextAuctionId().call();
        
        container.innerHTML = '';
        
        let hasFulfilled = false;
        
        for (let i = 1; i < nextId; i++) {
          try {
            const auction = await contract.methods.auctions(i).call();
            
            if (auction.state == 2) { // Fulfilled
              hasFulfilled = true;
              const finalPrice = web3.utils.fromWei(auction.highestBid, 'ether');
              
              const item = document.createElement('div');
              item.className = 'auction-item fulfilled';
              
              item.innerHTML = `
                <span>#${i}</span>
                <span class="address" title="${auction.seller}">${auction.seller.slice(0, 6)}...${auction.seller.slice(-4)}</span>
                <span title="${auction.title}">${auction.title || 'Untitled'}</span>
                <span class="price">${parseFloat(finalPrice).toFixed(3)} ETH</span>
                <span class="address" title="${auction.highestBidder || 'No winner'}">
                  ${auction.highestBidder ? 
                    `${auction.highestBidder.slice(0, 6)}...${auction.highestBidder.slice(-4)}` : 
                    'No winner'}
                </span>
              `;
              
              container.appendChild(item);
            }
          } catch (error) {
            continue;
          }
        }
        
        if (!hasFulfilled) {
          container.innerHTML = '<div class="no-items">No fulfilled auctions yet</div>';
        }
        
      } catch (error) {
        console.error("Error loading fulfilled auctions:", error);
      }
    }

    // -------------------
    // Section 5: Cancelled Auctions & Claim
    // -------------------
    async function loadCancelledAuctions() {
      try {
        const container = document.getElementById('cancelledAuctionList');
        
        // Use getCancelledAuctions if available
        try {
          const cancelledAuctions = await contract.methods.getCancelledAuctions().call();
          
          container.innerHTML = '';
          
          if (cancelledAuctions.length === 0) {
            container.innerHTML = '<div class="no-items">No cancelled auctions</div>';
            return;
          }
          
          for (const auction of cancelledAuctions) {
            const item = document.createElement('div');
            item.className = 'auction-item cancelled';
            
            item.innerHTML = `
              <span>#${auction.id}</span>
              <span class="address" title="${auction.seller}">${auction.seller.slice(0, 6)}...${auction.seller.slice(-4)}</span>
              <span title="${auction.title}">${auction.title || 'Untitled'}</span>
              <span class="status cancelled">Cancelled</span>
            `;
            
            container.appendChild(item);
          }
        } catch (e) {
          // Fallback method
          const nextId = await contract.methods.nextAuctionId().call();
          
          container.innerHTML = '';
          
          let hasCancelled = false;
          
          for (let i = 1; i < nextId; i++) {
            try {
              const auction = await contract.methods.auctions(i).call();
              
              if (auction.state == 3) { // Cancelled
                hasCancelled = true;
                
                const item = document.createElement('div');
                item.className = 'auction-item cancelled';
                
                item.innerHTML = `
                  <span>#${i}</span>
                  <span class="address" title="${auction.seller}">${auction.seller.slice(0, 6)}...${auction.seller.slice(-4)}</span>
                  <span title="${auction.title}">${auction.title || 'Untitled'}</span>
                  <span class="status cancelled">Cancelled</span>
                `;
                
                container.appendChild(item);
              }
            } catch (error) {
              continue;
            }
          }
          
          if (!hasCancelled) {
            container.innerHTML = '<div class="no-items">No cancelled auctions</div>';
          }
        }
        
      } catch (error) {
        console.error("Error loading cancelled auctions:", error);
      }
    }

    async function updateClaimUI() {
      try {
        const pending = await contract.methods.pendingRefunds(currentAddress).call();
        const pendingEth = web3.utils.fromWei(pending, 'ether');
        const claimBtn = document.getElementById('claimBtn');
        const claimInfo = document.getElementById('claimInfo');
        
        if (parseFloat(pendingEth) > 0) {
          claimBtn.disabled = false;
          claimInfo.textContent = `You can claim ${parseFloat(pendingEth).toFixed(3)} ETH`;
        } else {
          claimBtn.disabled = true;
          claimInfo.textContent = "You have no refunds to claim";
        }
      } catch (error) {
        console.error("Error updating claim UI:", error);
      }
    }

    async function claimRefunds() {
      const statusElement = document.getElementById('claimStatus');
      statusElement.textContent = "Processing claim...";
      statusElement.className = "status-message info";
      
      try {
        await contract.methods.claimRefund()
          .send({
            from: currentAddress,
            gas: 100000
          })
          .on('receipt', () => {
            statusElement.textContent = "✅ Refunds claimed successfully!";
            statusElement.className = "status-message success";
            updateClaimUI();
            setTimeout(() => {
              statusElement.textContent = '';
              statusElement.className = "status-message";
            }, 3000);
          })
          .on('error', (error) => {
            statusElement.textContent = "❌ Claim failed: " + error.message;
            statusElement.className = "status-message error";
          });
          
      } catch (error) {
        console.error("Claim error:", error);
        statusElement.textContent = "❌ Error: " + error.message;
        statusElement.className = "status-message error";
      }
    }

    // -------------------
    // Section 6: Admin Controls
    // -------------------
    async function withdrawFees() {
     if (!isOwner) {
       alert("Only contract owner can withdraw fees");
     return;
     }

   const statusElement = document.getElementById('adminStatus');
   statusElement.textContent = "Processing withdrawal...";
   statusElement.className = "status-message info";

   try {
     await contract.methods.withdrawPlatformFees()
      .send({ from: currentAddress, gas: 200000 })
      .on('receipt', () => {
        statusElement.textContent = "✅ Fees withdrawn successfully!";
        statusElement.className = "status-message success";
        setTimeout(() => {
          statusElement.textContent = '';
          statusElement.className = "status-message";
        }, 3000);
      })
      .on('error', (error) => {
        statusElement.textContent = "❌ Withdrawal failed: " + error.message;
        statusElement.className = "status-message error";
      });
    } catch (error) {
    console.error("Withdraw error:", error);
    statusElement.textContent = "❌ Error: " + error.message;
    statusElement.className = "status-message error";
    }
   }

    async function changeOwner() {
      if (!isOwner) {
        alert("Only contract owner can change owner");
        return;
      }
      
      const newOwner = document.getElementById('newOwner').value.trim();
      if (!newOwner || !web3.utils.isAddress(newOwner)) {
        alert("Please enter a valid Ethereum address");
        return;
      }
      
      if (!confirm(`Transfer ownership to ${newOwner}? This action cannot be undone!`)) {
        return;
      }
      
      const statusElement = document.getElementById('adminStatus');
      statusElement.textContent = "Transferring ownership...";
      statusElement.className = "status-message info";
      
      try {
        await contract.methods.transferOwnership(newOwner)
          .send({
            from: currentAddress,
            gas: 100000
          })
          .on('receipt', () => {
            statusElement.textContent = "✅ Ownership transferred successfully!";
            statusElement.className = "status-message success";
            document.getElementById('newOwner').value = '';
            setTimeout(() => {
              statusElement.textContent = '';
              statusElement.className = "status-message";
              checkOwnerStatus();
            }, 3000);
          })
          .on('error', (error) => {
            statusElement.textContent = "❌ Transfer failed: " + error.message;
            statusElement.className = "status-message error";
          });
          
      } catch (error) {
        console.error("Change owner error:", error);
        statusElement.textContent = "❌ Error: " + error.message;
        statusElement.className = "status-message error";
      }
    }

    async function banSeller() {
      if (!isOwner) {
        alert("Only contract owner can ban sellers");
        return;
      }
      
      const seller = document.getElementById('sellerToBan').value.trim();
      if (!seller || !web3.utils.isAddress(seller)) {
        alert("Please enter a valid Ethereum address");
        return;
      }
      
      if (!confirm(`Ban seller ${seller}? This will cancel all their active auctions!`)) {
        return;
      }
      
      const statusElement = document.getElementById('adminStatus');
      statusElement.textContent = "Banning seller...";
      statusElement.className = "status-message info";
      
      try {
        await contract.methods.ban(seller)
          .send({
            from: currentAddress,
            gas: 200000
          })
          .on('receipt', () => {
            statusElement.textContent = "✅ Seller banned successfully!";
            statusElement.className = "status-message success";
            document.getElementById('sellerToBan').value = '';
            setTimeout(() => {
              statusElement.textContent = '';
              statusElement.className = "status-message";
            }, 3000);
          })
          .on('error', (error) => {
            statusElement.textContent = "❌ Ban failed: " + error.message;
            statusElement.className = "status-message error";
          });
          
      } catch (error) {
        console.error("Ban seller error:", error);
        statusElement.textContent = "❌ Error: " + error.message;
        statusElement.className = "status-message error";
      }
    }

    async function destroyContract() {
      if (!isOwner) {
        alert("Only contract owner can destroy contract");
        return;
      }
      
      if (!confirm("⚠️ DESTROY CONTRACT ⚠️\n\nThis action is IRREVERSIBLE!\n\n• All active auctions will be cancelled\n• Contract will be paused\n• No new auctions can be created\n\nAre you ABSOLUTELY sure?")) {
        return;
      }
      
      const statusElement = document.getElementById('adminStatus');
      statusElement.textContent = "Destroying contract...";
      statusElement.className = "status-message info";
      
      try {
        await contract.methods.destroyContract()
          .send({
            from: currentAddress,
            gas: 200000
          })
          .on('receipt', () => {
            statusElement.textContent = "✅ Contract destroyed successfully!";
            statusElement.className = "status-message success";
            contractDestroyed = true;
            setTimeout(() => {
              statusElement.textContent = '';
              statusElement.className = "status-message";
              refreshAll();
            }, 3000);
          })
          .on('error', (error) => {
            statusElement.textContent = "❌ Destruction failed: " + error.message;
            statusElement.className = "status-message error";
          });
          
      } catch (error) {
        console.error("Destroy contract error:", error);
        statusElement.textContent = "❌ Error: " + error.message;
        statusElement.className = "status-message error";
      }
    }

    // Make functions available globally
    window.refreshAll = refreshAll;
    window.createAuction = createAuction;
    window.placeBid = placeBid;
    window.cancelAuction = cancelAuction;
    window.fulfillAuction = fulfillAuction;
    window.claimRefunds = claimRefunds;
    window.withdrawFees = withdrawFees;
    window.changeOwner = changeOwner;
    window.banSeller = banSeller;
    window.destroyContract = destroyContract;
